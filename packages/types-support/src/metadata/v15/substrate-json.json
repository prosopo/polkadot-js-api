{
  "magicNumber": 1635018093,
  "metadata": {
    "v15": {
      "pallets": [
        {
          "name": "System",
          "storage": {
            "prefix": "System",
            "items": [
              {
                "name": "Account",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hashers": [
                      "Blake2_128Concat"
                    ],
                    "key": 0,
                    "value": 3
                  }
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080",
                "docs": [
                  " The full account information for a particular account ID."
                ]
              },
              {
                "name": "ExtrinsicCount",
                "modifier": "Optional",
                "type": {
                  "plain": 4
                },
                "fallback": "0x00",
                "docs": [
                  " Total extrinsics count for the current block."
                ]
              },
              {
                "name": "BlockWeight",
                "modifier": "Default",
                "type": {
                  "plain": 8
                },
                "fallback": "0x000000000000",
                "docs": [
                  " The current weight for the block."
                ]
              },
              {
                "name": "AllExtrinsicsLen",
                "modifier": "Optional",
                "type": {
                  "plain": 4
                },
                "fallback": "0x00",
                "docs": [
                  " Total length (in bytes) for all extrinsics put together, for the current block."
                ]
              },
              {
                "name": "BlockHash",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hashers": [
                      "Twox64Concat"
                    ],
                    "key": 4,
                    "value": 12
                  }
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " Map of block numbers to block hashes."
                ]
              },
              {
                "name": "ExtrinsicData",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hashers": [
                      "Twox64Concat"
                    ],
                    "key": 4,
                    "value": 13
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Extrinsics data for the current block (maps an extrinsic's index to its data)."
                ]
              },
              {
                "name": "Number",
                "modifier": "Default",
                "type": {
                  "plain": 4
                },
                "fallback": "0x00000000",
                "docs": [
                  " The current block number being processed. Set by `execute_block`."
                ]
              },
              {
                "name": "ParentHash",
                "modifier": "Default",
                "type": {
                  "plain": 12
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " Hash of the previous block."
                ]
              },
              {
                "name": "Digest",
                "modifier": "Default",
                "type": {
                  "plain": 14
                },
                "fallback": "0x00",
                "docs": [
                  " Digest of the current block, also part of the block header."
                ]
              },
              {
                "name": "Events",
                "modifier": "Default",
                "type": {
                  "plain": 18
                },
                "fallback": "0x00",
                "docs": [
                  " Events deposited for the current block.",
                  "",
                  " NOTE: The item is unbound and should therefore never be read on chain.",
                  " It could otherwise inflate the PoV size of a block.",
                  "",
                  " Events have a large in-memory size. Box the events to not go out-of-memory",
                  " just in case someone still reads them from within the runtime."
                ]
              },
              {
                "name": "EventCount",
                "modifier": "Default",
                "type": {
                  "plain": 4
                },
                "fallback": "0x00000000",
                "docs": [
                  " The number of events in the `Events<T>` list."
                ]
              },
              {
                "name": "EventTopics",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hashers": [
                      "Blake2_128Concat"
                    ],
                    "key": 12,
                    "value": 456
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Mapping between a topic (represented by T::Hash) and a vector of indexes",
                  " of events in the `<Events<T>>` list.",
                  "",
                  " All topic vectors have deterministic storage locations depending on the topic. This",
                  " allows light-clients to leverage the changes trie storage tracking mechanism and",
                  " in case of changes fetch the list of events of interest.",
                  "",
                  " The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just",
                  " the `EventIndex` then in case if the topic has the same contents on the next block",
                  " no notification will be triggered thus the event might be lost."
                ]
              },
              {
                "name": "LastRuntimeUpgrade",
                "modifier": "Optional",
                "type": {
                  "plain": 457
                },
                "fallback": "0x00",
                "docs": [
                  " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."
                ]
              },
              {
                "name": "UpgradedToU32RefCount",
                "modifier": "Default",
                "type": {
                  "plain": 43
                },
                "fallback": "0x00",
                "docs": [
                  " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."
                ]
              },
              {
                "name": "UpgradedToTripleRefCount",
                "modifier": "Default",
                "type": {
                  "plain": 43
                },
                "fallback": "0x00",
                "docs": [
                  " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False",
                  " (default) if not."
                ]
              },
              {
                "name": "ExecutionPhase",
                "modifier": "Optional",
                "type": {
                  "plain": 454
                },
                "fallback": "0x00",
                "docs": [
                  " The execution phase of the block."
                ]
              }
            ]
          },
          "calls": {
            "type": 142
          },
          "events": {
            "type": 21
          },
          "constants": [
            {
              "name": "BlockWeights",
              "type": 459,
              "value": "0x025b1f5d000b00204aa9d10113ffffffffffffffffc2a0a91d00010bd05f9fa62e011366666666666666a6010b0098f73e5d0113ffffffffffffffbf010000c2a0a91d00010bd0e7f110a3011366666666666666e6010b00204aa9d10113ffffffffffffffff01070088526a74130000000000000040c2a0a91d00000000",
              "docs": [
                " Block & extrinsics weights: base values and limits."
              ]
            },
            {
              "name": "BlockLength",
              "type": 462,
              "value": "0x00003c000000500000005000",
              "docs": [
                " The maximum length of a block (in bytes)."
              ]
            },
            {
              "name": "BlockHashCount",
              "type": 4,
              "value": "0x60090000",
              "docs": [
                " Maximum number of block number to block hash mappings to keep (oldest pruned first)."
              ]
            },
            {
              "name": "DbWeight",
              "type": 464,
              "value": "0x40787d010000000000e1f50500000000",
              "docs": [
                " The weight of runtime database operations the runtime can invoke."
              ]
            },
            {
              "name": "Version",
              "type": 465,
              "value": "0x106e6f6465387375627374726174652d6e6f64650a0000000c0100000000000050df6acb689907609b0400000037e397fc7c91f5e40200000040fe3ad401f8959a06000000d2bc9897eed08f1503000000be9fb0c91a8046cf01000000f78b278be53f454c02000000ed99c5acb25eedf50300000017a6bc0d0062aeb30100000018ef58a3b67ba77001000000cbca25e39f14238702000000687ad44ad37f03c201000000bc9d89904f5b923f010000008453b50b222939770100000068b66ba122c93fa70200000037c8bb1350a9a2a8040000008a8047a53a8277ec01000000f3ff14d5ab52705903000000899a250cbe84f2500100000091d5df18b0d2cf5802000000ab3c0572291feb8b010000000200000001",
              "docs": [
                " Get the chain's current version."
              ]
            },
            {
              "name": "SS58Prefix",
              "type": 101,
              "value": "0x2a00",
              "docs": [
                " The designated SS58 prefix of this chain.",
                "",
                " This replaces the \"ss58Format\" property declared in the chain spec. Reason is",
                " that the runtime should know about the prefix in order to make use of it as",
                " an identifier of the chain."
              ]
            }
          ],
          "errors": {
            "type": 469
          },
          "index": 0,
          "docs": []
        },
        {
          "name": "Utility",
          "storage": null,
          "calls": {
            "type": 146
          },
          "events": {
            "type": 30
          },
          "constants": [
            {
              "name": "batched_calls_limit",
              "type": 4,
              "value": "0xaa2a0000",
              "docs": [
                " The limit on the number of batched calls."
              ]
            }
          ],
          "errors": {
            "type": 470
          },
          "index": 1,
          "docs": []
        },
        {
          "name": "Babe",
          "storage": {
            "prefix": "Babe",
            "items": [
              {
                "name": "EpochIndex",
                "modifier": "Default",
                "type": {
                  "plain": 11
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " Current epoch index."
                ]
              },
              {
                "name": "Authorities",
                "modifier": "Default",
                "type": {
                  "plain": 471
                },
                "fallback": "0x00",
                "docs": [
                  " Current epoch authorities."
                ]
              },
              {
                "name": "GenesisSlot",
                "modifier": "Default",
                "type": {
                  "plain": 159
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " The slot at which the first epoch actually started. This is 0",
                  " until the first block of the chain."
                ]
              },
              {
                "name": "CurrentSlot",
                "modifier": "Default",
                "type": {
                  "plain": 159
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " Current slot number."
                ]
              },
              {
                "name": "Randomness",
                "modifier": "Default",
                "type": {
                  "plain": 1
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " The epoch randomness for the *current* epoch.",
                  "",
                  " # Security",
                  "",
                  " This MUST NOT be used for gambling, as it can be influenced by a",
                  " malicious validator in the short term. It MAY be used in many",
                  " cryptographic protocols, however, so long as one remembers that this",
                  " (like everything else on-chain) it is public. For example, it can be",
                  " used where a number is needed that cannot have been chosen by an",
                  " adversary, for purposes such as public-coin zero-knowledge proofs."
                ]
              },
              {
                "name": "PendingEpochConfigChange",
                "modifier": "Optional",
                "type": {
                  "plain": 161
                },
                "fallback": "0x00",
                "docs": [
                  " Pending epoch configuration change that will be applied when the next epoch is enacted."
                ]
              },
              {
                "name": "NextRandomness",
                "modifier": "Default",
                "type": {
                  "plain": 1
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "docs": [
                  " Next epoch randomness."
                ]
              },
              {
                "name": "NextAuthorities",
                "modifier": "Default",
                "type": {
                  "plain": 471
                },
                "fallback": "0x00",
                "docs": [
                  " Next epoch authorities."
                ]
              },
              {
                "name": "SegmentIndex",
                "modifier": "Default",
                "type": {
                  "plain": 4
                },
                "fallback": "0x00000000",
                "docs": [
                  " Randomness under construction.",
                  "",
                  " We make a trade-off between storage accesses and list length.",
                  " We store the under-construction randomness in segments of up to",
                  " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.",
                  "",
                  " Once a segment reaches this length, we begin the next one.",
                  " We reset all segments and return to `0` at the beginning of every",
                  " epoch."
                ]
              },
              {
                "name": "UnderConstruction",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hashers": [
                      "Twox64Concat"
                    ],
                    "key": 4,
                    "value": 474
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."
                ]
              },
              {
                "name": "Initialized",
                "modifier": "Optional",
                "type": {
                  "plain": 476
                },
                "fallback": "0x00",
                "docs": [
                  " Temporary value (cleared at block finalization) which is `Some`",
                  " if per-block initialization has already been called for current block."
                ]
              },
              {
                "name": "AuthorVrfRandomness",
                "modifier": "Default",
                "type": {
                  "plain": 95
                },
                "fallback": "0x00",
                "docs": [
                  " This field should always be populated during block processing unless",
                  " secondary plain slots are enabled (which don't contain a VRF output).",
                  "",
                  " It is set in `on_finalize`, before it will contain the value from the last block."
                ]
              },
              {
                "name": "EpochStart",
                "modifier": "Default",
                "type": {
                  "plain": 94
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " The block numbers when the last and current epoch have started, respectively `N-1` and",
                  " `N`.",
                  " NOTE: We track this is in order to annotate the block number when a given pool of",
                  " entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in",
                  " slots, which may be skipped, the block numbers may not line up with the slot numbers."
                ]
              },
              {
                "name": "Lateness",
                "modifier": "Default",
                "type": {
                  "plain": 4
                },
                "fallback": "0x00000000",
                "docs": [
                  " How late the current block is compared to its parent.",
                  "",
                  " This entry is populated as part of block execution and is cleaned up",
                  " on block finalization. Querying this storage entry outside of block",
                  " execution context should always yield zero."
                ]
              },
              {
                "name": "EpochConfig",
                "modifier": "Optional",
                "type": {
                  "plain": 482
                },
                "fallback": "0x00",
                "docs": [
                  " The configuration for the current epoch. Should never be `None` as it is initialized in",
                  " genesis."
                ]
              },
              {
                "name": "NextEpochConfig",
                "modifier": "Optional",
                "type": {
                  "plain": 482
                },
                "fallback": "0x00",
                "docs": [
                  " The configuration for the next epoch, `None` if the config will not change",
                  " (you can fallback to `EpochConfig` instead in that case)."
                ]
              },
              {
                "name": "SkippedEpochs",
                "modifier": "Default",
                "type": {
                  "plain": 483
                },
                "fallback": "0x00",
                "docs": [
                  " A list of the last 100 skipped epochs and the corresponding session index",
                  " when the epoch was skipped.",
                  "",
                  " This is only used for validating equivocation proofs. An equivocation proof",
                  " must contains a key-ownership proof for a given session, therefore we need a",
                  " way to tie together sessions and epoch indices, i.e. we need to validate that",
                  " a validator was the owner of a given key on a given session, and what the",
                  " active epoch index was during that session."
                ]
              }
            ]
          },
          "calls": {
            "type": 154
          },
          "events": null,
          "constants": [
            {
              "name": "EpochDuration",
              "type": 11,
              "value": "0xc800000000000000",
              "docs": [
                " The amount of time, in slots, that each epoch should last.",
                " NOTE: Currently it is not possible to change the epoch duration after",
                " the chain has started. Attempting to do so will brick block production."
              ]
            },
            {
              "name": "ExpectedBlockTime",
              "type": 11,
              "value": "0xb80b000000000000",
              "docs": [
                " The expected average block time at which BABE should be creating",
                " blocks. Since BABE is probabilistic it is not trivial to figure out",
                " what the expected average block time should be based on the slot",
                " duration and the security parameter `c` (where `1 - c` represents",
                " the probability of a slot being empty)."
              ]
            },
            {
              "name": "MaxAuthorities",
              "type": 4,
              "value": "0x64000000",
              "docs": [
                " Max number of authorities allowed"
              ]
            },
            {
              "name": "MaxNominators",
              "type": 4,
              "value": "0x00010000",
              "docs": [
                " The maximum number of nominators for each validator."
              ]
            }
          ],
          "errors": {
            "type": 486
          },
          "index": 2,
          "docs": []
        },
        {
          "name": "Timestamp",
          "storage": {
            "prefix": "Timestamp",
            "items": [
              {
                "name": "Now",
                "modifier": "Default",
                "type": {
                  "plain": 11
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " Current time for the current block."
                ]
              },
              {
                "name": "DidUpdate",
                "modifier": "Default",
                "type": {
                  "plain": 43
                },
                "fallback": "0x00",
                "docs": [
                  " Did the timestamp get updated in this block?"
                ]
              }
            ]
          },
          "calls": {
            "type": 164
          },
          "events": null,
          "constants": [
            {
              "name": "MinimumPeriod",
              "type": 11,
              "value": "0xdc05000000000000",
              "docs": [
                " The minimum period between blocks. Beware that this is different to the *expected*",
                " period that the block production apparatus provides. Your chosen consensus system will",
                " generally work with this to determine a sensible block time. e.g. For Aura, it will be",
                " double this period on default settings."
              ]
            }
          ],
          "errors": null,
          "index": 3,
          "docs": []
        },
        {
          "name": "Balances",
          "storage": {
            "prefix": "Balances",
            "items": [
              {
                "name": "TotalIssuance",
                "modifier": "Default",
                "type": {
                  "plain": 6
                },
                "fallback": "0x00000000000000000000000000000000",
                "docs": [
                  " The total units issued in the system."
                ]
              },
              {
                "name": "InactiveIssuance",
                "modifier": "Default",
                "type": {
                  "plain": 6
                },
                "fallback": "0x00000000000000000000000000000000",
                "docs": [
                  " The total units of outstanding deactivated balance in the system."
                ]
              },
              {
                "name": "Account",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hashers": [
                      "Blake2_128Concat"
                    ],
                    "key": 0,
                    "value": 5
                  }
                },
                "fallback": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080",
                "docs": [
                  " The Balances pallet example of storing the balance of an account.",
                  "",
                  " # Example",
                  "",
                  " ```nocompile",
                  "  impl pallet_balances::Config for Runtime {",
                  "    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>",
                  "  }",
                  " ```",
                  "",
                  " You can also store the balance of an account in the `System` pallet.",
                  "",
                  " # Example",
                  "",
                  " ```nocompile",
                  "  impl pallet_balances::Config for Runtime {",
                  "   type AccountStore = System",
                  "  }",
                  " ```",
                  "",
                  " But this comes with tradeoffs, storing account balances in the system pallet stores",
                  " `frame_system` data alongside the account data contrary to storing account balances in the",
                  " `Balances` pallet, which uses a `StorageMap` to store balances data only.",
                  " NOTE: This is only used in the case that this pallet is used to store balances."
                ]
              },
              {
                "name": "Locks",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hashers": [
                      "Blake2_128Concat"
                    ],
                    "key": 0,
                    "value": 489
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Any liquidity locks on some account balances.",
                  " NOTE: Should only be accessed when setting, changing and freeing a lock."
                ]
              },
              {
                "name": "Reserves",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hashers": [
                      "Blake2_128Concat"
                    ],
                    "key": 0,
                    "value": 493
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Named reserves on some account balances."
                ]
              },
              {
                "name": "Holds",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hashers": [
                      "Blake2_128Concat"
                    ],
                    "key": 0,
                    "value": 496
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Holds on account balances."
                ]
              },
              {
                "name": "Freezes",
                "modifier": "Default",
                "type": {
                  "map": {
                    "hashers": [
                      "Blake2_128Concat"
                    ],
                    "key": 0,
                    "value": 504
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Freeze locks on account balances."
                ]
              }
            ]
          },
          "calls": {
            "type": 168
          },
          "events": {
            "type": 34
          },
          "constants": [
            {
              "name": "ExistentialDeposit",
              "type": 6,
              "value": "0x00407a10f35a00000000000000000000",
              "docs": [
                " The minimum amount required to keep an account open. MUST BE GREATER THAN ZERO!",
                "",
                " If you *really* need it to be zero, you can enable the feature `insecure_zero_ed` for",
                " this pallet. However, you do so at your own risk: this will open up a major DoS vector.",
                " In case you have multiple sources of provider references, you may also get unexpected",
                " behaviour if you set this to zero.",
                "",
                " Bottom line: Do yourself a favour and make it at least one!"
              ]
            },
            {
              "name": "MaxLocks",
              "type": 4,
              "value": "0x32000000",
              "docs": [
                " The maximum number of locks that should exist on an account.",
                " Not strictly enforced, but used for weight estimation."
              ]
            },
            {
              "name": "MaxReserves",
              "type": 4,
              "value": "0x32000000",
              "docs": [
                " The maximum number of named reserves that can exist on an account."
              ]
            },
            {
              "name": "MaxHolds",
              "type": 4,
              "value": "0x02000000",
              "docs": [
                " The maximum number of holds that can exist on an account at any time."
              ]
            },
            {
              "name": "MaxFreezes",
              "type": 4,
              "value": "0x00000000",
              "docs": [
                " The maximum number of individual freeze locks that can exist on an account at any time."
              ]
            }
          ],
          "errors": {
            "type": 507
          },
          "index": 6,
          "docs": []
        },
        {
          "name": "Contracts",
          "storage": {
            "prefix": "Contracts",
            "items": [
              {
                "name": "PristineCode",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hashers": [
                      "Identity"
                    ],
                    "key": 12,
                    "value": 583
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " A mapping from a contract's code hash to its code."
                ]
              },
              {
                "name": "CodeInfoOf",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hashers": [
                      "Identity"
                    ],
                    "key": 12,
                    "value": 584
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " A mapping from a contract's code hash to its code info."
                ]
              },
              {
                "name": "Nonce",
                "modifier": "Default",
                "type": {
                  "plain": 11
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " This is a **monotonic** counter incremented on contract instantiation.",
                  "",
                  " This is used in order to generate unique trie ids for contracts.",
                  " The trie id of a new contract is calculated from hash(account_id, nonce).",
                  " The nonce is required because otherwise the following sequence would lead to",
                  " a possible collision of storage:",
                  "",
                  " 1. Create a new contract.",
                  " 2. Terminate the contract.",
                  " 3. Immediately recreate the contract with the same account_id.",
                  "",
                  " This is bad because the contents of a trie are deleted lazily and there might be",
                  " storage of the old instantiation still in it when the new contract is created. Please",
                  " note that we can't replace the counter by the block number because the sequence above",
                  " can happen in the same block. We also can't keep the account counter in memory only",
                  " because storage is the only way to communicate across different extrinsics in the",
                  " same block.",
                  "",
                  " # Note",
                  "",
                  " Do not use it to determine the number of contracts. It won't be decremented if",
                  " a contract is destroyed."
                ]
              },
              {
                "name": "ContractInfoOf",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hashers": [
                      "Twox64Concat"
                    ],
                    "key": 0,
                    "value": 585
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " The code associated with a given account.",
                  "",
                  " TWOX-NOTE: SAFE since `AccountId` is a secure hash."
                ]
              },
              {
                "name": "DeletionQueue",
                "modifier": "Optional",
                "type": {
                  "map": {
                    "hashers": [
                      "Twox64Concat"
                    ],
                    "key": 4,
                    "value": 113
                  }
                },
                "fallback": "0x00",
                "docs": [
                  " Evicted contracts that await child trie deletion.",
                  "",
                  " Child trie deletion is a heavy operation depending on the amount of storage items",
                  " stored in said trie. Therefore this operation is performed lazily in `on_idle`."
                ]
              },
              {
                "name": "DeletionQueueCounter",
                "modifier": "Default",
                "type": {
                  "plain": 590
                },
                "fallback": "0x0000000000000000",
                "docs": [
                  " A pair of monotonic counters used to track the latest contract marked for deletion",
                  " and the latest deleted contract in queue."
                ]
              },
              {
                "name": "MigrationInProgress",
                "modifier": "Optional",
                "type": {
                  "plain": 591
                },
                "fallback": "0x00",
                "docs": [
                  " A migration can span across multiple blocks. This storage defines a cursor to track the",
                  " progress of the migration, enabling us to resume from the last completed position."
                ]
              }
            ]
          },
          "calls": {
            "type": 260
          },
          "events": {
            "type": 72
          },
          "constants": [
            {
              "name": "Schedule",
              "type": 592,
              "value": "0x04000000000100000004000080000000100000000010000000010000200000000040000000000008a21400007642150018bebed106f1290ac60907012a126d1a0018a22a0b000cd22b0a000c5e0b15001882962100187e7f63001862891600184256150018c6be1500181e891500186e145700383e64120018550f00de152e00b409050003f2e7cb4d4952027c7600284248ed002806377a1e3127c10900723a0f001c551000ba056b1f9504510800c50e04ca39c54749309eac621f85040004a2bc37078504410404369a4307a5047d0604de97681fa50459080482ee2927612736971a76852a3abe0a643529caa81995ad517d0f00ce8310f8ad2a86449d38d5272d1d002d1e00ba8d180020291100f2e631002055340046a71c0020d11200de091c0020d112001224fe0a3501f27ddf02a8e273630dc1016d5c04f63c0b000c1a0f1300a0dee709000c86d2551fb92846a8271f2128",
              "docs": [
                " Cost schedule and limits."
              ]
            },
            {
              "name": "DepositPerByte",
              "type": 6,
              "value": "0x0060defb740500000000000000000000",
              "docs": [
                " The amount of balance a caller has to pay for each byte of storage.",
                "",
                " # Note",
                "",
                " Changing this value for an existing chain might need a storage migration."
              ]
            },
            {
              "name": "DefaultDepositLimit",
              "type": 6,
              "value": "0x0000c0afbc4f86570000000000000000",
              "docs": [
                " Fallback value to limit the storage deposit if it's not being set by the caller."
              ]
            },
            {
              "name": "DepositPerItem",
              "type": 6,
              "value": "0x00f0ab75a40d00000000000000000000",
              "docs": [
                " The amount of balance a caller has to pay for each storage item.",
                "",
                " # Note",
                "",
                " Changing this value for an existing chain might need a storage migration."
              ]
            },
            {
              "name": "CodeHashLockupDepositPercent",
              "type": 48,
              "value": "0x00a3e111",
              "docs": [
                " The percentage of the storage deposit that should be held for using a code hash.",
                " Instantiating a contract, or calling [`chain_extension::Ext::add_delegate_dependency`]",
                " protects the code from being removed. In order to prevent abuse these actions are",
                " protected with a percentage of the code deposit."
              ]
            },
            {
              "name": "MaxCodeLen",
              "type": 4,
              "value": "0x00ec0100",
              "docs": [
                " The maximum length of a contract code in bytes.",
                "",
                " The value should be chosen carefully taking into the account the overall memory limit",
                " your runtime has, as well as the [maximum allowed callstack",
                " depth](#associatedtype.CallStack). Look into the `integrity_test()` for some insights."
              ]
            },
            {
              "name": "MaxStorageKeyLen",
              "type": 4,
              "value": "0x80000000",
              "docs": [
                " The maximum allowable length in bytes for storage keys."
              ]
            },
            {
              "name": "MaxDelegateDependencies",
              "type": 4,
              "value": "0x20000000",
              "docs": [
                " The maximum number of delegate_dependencies that a contract can lock with",
                " [`chain_extension::Ext::add_delegate_dependency`]."
              ]
            },
            {
              "name": "UnsafeUnstableInterface",
              "type": 43,
              "value": "0x00",
              "docs": [
                " Make contract callable functions marked as `#[unstable]` available.",
                "",
                " Contracts that use `#[unstable]` functions won't be able to be uploaded unless",
                " this is set to `true`. This is only meant for testnets and dev nodes in order to",
                " experiment with new features.",
                "",
                " # Warning",
                "",
                " Do **not** set to `true` on productions chains."
              ]
            },
            {
              "name": "MaxDebugBufferLen",
              "type": 4,
              "value": "0x00002000",
              "docs": [
                " The maximum length of the debug buffer in bytes."
              ]
            },
            {
              "name": "Environment",
              "type": 596,
              "value": "0x",
              "docs": [
                " Type that bundles together all the runtime configurable interface types.",
                "",
                " This is not a real config. We just mention the type here as constant so that",
                " its type appears in the metadata. Only valid value is `()`."
              ]
            }
          ],
          "errors": {
            "type": 604
          },
          "index": 21,
          "docs": []
        }
      ],
      "extrinsic": {
        "version": 4,
        "addressType": 166,
        "callType": 141,
        "signatureType": 349,
        "extraType": 854,
        "signedExtensions": [
          {
            "identifier": "CheckNonZeroSender",
            "type": 855,
            "additionalSigned": 32
          },
          {
            "identifier": "CheckSpecVersion",
            "type": 856,
            "additionalSigned": 4
          },
          {
            "identifier": "CheckTxVersion",
            "type": 857,
            "additionalSigned": 4
          },
          {
            "identifier": "CheckGenesis",
            "type": 858,
            "additionalSigned": 12
          },
          {
            "identifier": "CheckMortality",
            "type": 859,
            "additionalSigned": 12
          },
          {
            "identifier": "CheckNonce",
            "type": 861,
            "additionalSigned": 32
          },
          {
            "identifier": "CheckWeight",
            "type": 862,
            "additionalSigned": 32
          },
          {
            "identifier": "ChargeAssetTxPayment",
            "type": 863,
            "additionalSigned": 32
          }
        ]
      },
      "type": 74,
      "apis": [
        {
          "name": "Core",
          "methods": [
            {
              "name": "version",
              "inputs": [],
              "output": 465,
              "docs": [
                " Returns the version of the runtime."
              ]
            },
            {
              "name": "execute_block",
              "inputs": [
                {
                  "name": "block",
                  "type": 864
                }
              ],
              "output": 32,
              "docs": [
                " Execute the given block."
              ]
            },
            {
              "name": "initialize_block",
              "inputs": [
                {
                  "name": "header",
                  "type": 156
                }
              ],
              "output": 32,
              "docs": [
                " Initialize a block with the given header."
              ]
            }
          ],
          "docs": [
            " The `Core` runtime api that every Substrate runtime needs to implement."
          ]
        },
        {
          "name": "Metadata",
          "methods": [
            {
              "name": "metadata",
              "inputs": [],
              "output": 867,
              "docs": [
                " Returns the metadata of a runtime."
              ]
            },
            {
              "name": "metadata_at_version",
              "inputs": [
                {
                  "name": "version",
                  "type": 4
                }
              ],
              "output": 868,
              "docs": [
                " Returns the metadata at a given version.",
                "",
                " If the given `version` isn't supported, this will return `None`.",
                " Use [`Self::metadata_versions`] to find out about supported metadata version of the runtime."
              ]
            },
            {
              "name": "metadata_versions",
              "inputs": [],
              "output": 114,
              "docs": [
                " Returns the supported metadata versions.",
                "",
                " This can be used to call `metadata_at_version`."
              ]
            }
          ],
          "docs": [
            " The `Metadata` api trait that returns metadata for the runtime."
          ]
        },
        {
          "name": "BlockBuilder",
          "methods": [
            {
              "name": "apply_extrinsic",
              "inputs": [
                {
                  "name": "extrinsic",
                  "type": 865
                }
              ],
              "output": 869,
              "docs": [
                " Apply the given extrinsic.",
                "",
                " Returns an inclusion outcome which specifies if this extrinsic is included in",
                " this block or not."
              ]
            },
            {
              "name": "finalize_block",
              "inputs": [],
              "output": 156,
              "docs": [
                " Finish the current block."
              ]
            },
            {
              "name": "inherent_extrinsics",
              "inputs": [
                {
                  "name": "inherent",
                  "type": 873
                }
              ],
              "output": 866,
              "docs": [
                " Generate inherent extrinsics. The inherent data will vary from chain to chain."
              ]
            },
            {
              "name": "check_inherents",
              "inputs": [
                {
                  "name": "block",
                  "type": 864
                },
                {
                  "name": "data",
                  "type": 873
                }
              ],
              "output": 877,
              "docs": [
                " Check that the inherents are valid. The inherent data will vary from chain to chain."
              ]
            }
          ],
          "docs": [
            " The `BlockBuilder` api trait that provides the required functionality for building a block."
          ]
        },
        {
          "name": "TaggedTransactionQueue",
          "methods": [
            {
              "name": "validate_transaction",
              "inputs": [
                {
                  "name": "source",
                  "type": 878
                },
                {
                  "name": "tx",
                  "type": 865
                },
                {
                  "name": "block_hash",
                  "type": 12
                }
              ],
              "output": 879,
              "docs": [
                " Validate the transaction.",
                "",
                " This method is invoked by the transaction pool to learn details about given transaction.",
                " The implementation should make sure to verify the correctness of the transaction",
                " against current state. The given `block_hash` corresponds to the hash of the block",
                " that is used as current state.",
                "",
                " Note that this call may be performed by the pool multiple times and transactions",
                " might be verified in any possible order."
              ]
            }
          ],
          "docs": [
            " The `TaggedTransactionQueue` api trait for interfering with the transaction queue."
          ]
        },
        {
          "name": "ValidateStatement",
          "methods": [
            {
              "name": "validate_statement",
              "inputs": [
                {
                  "name": "source",
                  "type": 881
                },
                {
                  "name": "statement",
                  "type": 443
                }
              ],
              "output": 882,
              "docs": [
                " Validate the statement."
              ]
            }
          ],
          "docs": [
            " Runtime API trait for statement validation."
          ]
        },
        {
          "name": "OffchainWorkerApi",
          "methods": [
            {
              "name": "offchain_worker",
              "inputs": [
                {
                  "name": "header",
                  "type": 156
                }
              ],
              "output": 32,
              "docs": [
                " Starts the off-chain task for given block header."
              ]
            }
          ],
          "docs": [
            " The offchain worker api."
          ]
        },
        {
          "name": "GrandpaApi",
          "methods": [
            {
              "name": "grandpa_authorities",
              "inputs": [],
              "output": 65,
              "docs": [
                " Get the current GRANDPA authorities and weights. This should not change except",
                " for when changes are scheduled and the corresponding delay has passed.",
                "",
                " When called at block B, it will return the set of authorities that should be",
                " used to finalize descendants of this block (B+1, B+2, ...). The block B itself",
                " is finalized by the authorities from block B-1."
              ]
            },
            {
              "name": "submit_report_equivocation_unsigned_extrinsic",
              "inputs": [
                {
                  "name": "equivocation_proof",
                  "type": 247
                },
                {
                  "name": "key_owner_proof",
                  "type": 885
                }
              ],
              "output": 886,
              "docs": [
                " Submits an unsigned extrinsic to report an equivocation. The caller",
                " must provide the equivocation proof and a key ownership proof",
                " (should be obtained using `generate_key_ownership_proof`). The",
                " extrinsic will be unsigned and should only be accepted for local",
                " authorship (not to be broadcast to the network). This method returns",
                " `None` when creation of the extrinsic fails, e.g. if equivocation",
                " reporting is disabled for the given runtime (i.e. this method is",
                " hardcoded to return `None`). Only useful in an offchain context."
              ]
            },
            {
              "name": "generate_key_ownership_proof",
              "inputs": [
                {
                  "name": "set_id",
                  "type": 11
                },
                {
                  "name": "authority_id",
                  "type": 67
                }
              ],
              "output": 887,
              "docs": [
                " Generates a proof of key ownership for the given authority in the",
                " given set. An example usage of this module is coupled with the",
                " session historical module to prove that a given authority key is",
                " tied to a given staking identity during a specific session. Proofs",
                " of key ownership are necessary for submitting equivocation reports.",
                " NOTE: even though the API takes a `set_id` as parameter the current",
                " implementations ignore this parameter and instead rely on this",
                " method being called at the correct block height, i.e. any point at",
                " which the given set id is live on-chain. Future implementations will",
                " instead use indexed data through an offchain worker, not requiring",
                " older states to be available."
              ]
            },
            {
              "name": "current_set_id",
              "inputs": [],
              "output": 11,
              "docs": [
                " Get current GRANDPA authority set id."
              ]
            }
          ],
          "docs": [
            " APIs for integrating the GRANDPA finality gadget into runtimes.",
            " This should be implemented on the runtime side.",
            "",
            " This is primarily used for negotiating authority-set changes for the",
            " gadget. GRANDPA uses a signaling model of changing authority sets:",
            " changes should be signaled with a delay of N blocks, and then automatically",
            " applied in the runtime after those N blocks have passed.",
            "",
            " The consensus protocol will coordinate the handoff externally."
          ]
        },
        {
          "name": "NominationPoolsApi",
          "methods": [
            {
              "name": "pending_rewards",
              "inputs": [
                {
                  "name": "who",
                  "type": 0
                }
              ],
              "output": 6,
              "docs": [
                " Returns the pending rewards for the member that the AccountId was given for."
              ]
            },
            {
              "name": "points_to_balance",
              "inputs": [
                {
                  "name": "pool_id",
                  "type": 4
                },
                {
                  "name": "points",
                  "type": 6
                }
              ],
              "output": 6,
              "docs": [
                " Returns the equivalent balance of `points` for a given pool."
              ]
            },
            {
              "name": "balance_to_points",
              "inputs": [
                {
                  "name": "pool_id",
                  "type": 4
                },
                {
                  "name": "new_funds",
                  "type": 6
                }
              ],
              "output": 6,
              "docs": [
                " Returns the equivalent points of `new_funds` for a given pool."
              ]
            }
          ],
          "docs": [
            " Runtime api for accessing information about nomination pools."
          ]
        },
        {
          "name": "StakingApi",
          "methods": [
            {
              "name": "nominations_quota",
              "inputs": [
                {
                  "name": "balance",
                  "type": 6
                }
              ],
              "output": 4,
              "docs": [
                " Returns the nominations quota for a nominator with a given balance."
              ]
            }
          ],
          "docs": []
        },
        {
          "name": "BabeApi",
          "methods": [
            {
              "name": "configuration",
              "inputs": [],
              "output": 888,
              "docs": [
                " Return the configuration for BABE."
              ]
            },
            {
              "name": "current_epoch_start",
              "inputs": [],
              "output": 159,
              "docs": [
                " Returns the slot that started the current epoch."
              ]
            },
            {
              "name": "current_epoch",
              "inputs": [],
              "output": 889,
              "docs": [
                " Returns information regarding the current epoch."
              ]
            },
            {
              "name": "next_epoch",
              "inputs": [],
              "output": 889,
              "docs": [
                " Returns information regarding the next epoch (which was already",
                " previously announced)."
              ]
            },
            {
              "name": "generate_key_ownership_proof",
              "inputs": [
                {
                  "name": "slot",
                  "type": 159
                },
                {
                  "name": "authority_id",
                  "type": 158
                }
              ],
              "output": 890,
              "docs": [
                " Generates a proof of key ownership for the given authority in the",
                " current epoch. An example usage of this module is coupled with the",
                " session historical module to prove that a given authority key is",
                " tied to a given staking identity during a specific session. Proofs",
                " of key ownership are necessary for submitting equivocation reports.",
                " NOTE: even though the API takes a `slot` as parameter the current",
                " implementations ignores this parameter and instead relies on this",
                " method being called at the correct block height, i.e. any point at",
                " which the epoch for the given slot is live on-chain. Future",
                " implementations will instead use indexed data through an offchain",
                " worker, not requiring older states to be available."
              ]
            },
            {
              "name": "submit_report_equivocation_unsigned_extrinsic",
              "inputs": [
                {
                  "name": "equivocation_proof",
                  "type": 155
                },
                {
                  "name": "key_owner_proof",
                  "type": 891
                }
              ],
              "output": 886,
              "docs": [
                " Submits an unsigned extrinsic to report an equivocation. The caller",
                " must provide the equivocation proof and a key ownership proof",
                " (should be obtained using `generate_key_ownership_proof`). The",
                " extrinsic will be unsigned and should only be accepted for local",
                " authorship (not to be broadcast to the network). This method returns",
                " `None` when creation of the extrinsic fails, e.g. if equivocation",
                " reporting is disabled for the given runtime (i.e. this method is",
                " hardcoded to return `None`). Only useful in an offchain context."
              ]
            }
          ],
          "docs": [
            " API necessary for block authorship with BABE."
          ]
        },
        {
          "name": "AuthorityDiscoveryApi",
          "methods": [
            {
              "name": "authorities",
              "inputs": [],
              "output": 610,
              "docs": [
                " Retrieve authority identifiers of the current and next authority set."
              ]
            }
          ],
          "docs": [
            " The authority discovery api.",
            "",
            " This api is used by the `client/authority-discovery` module to retrieve identifiers",
            " of the current and next authority set."
          ]
        },
        {
          "name": "AccountNonceApi",
          "methods": [
            {
              "name": "account_nonce",
              "inputs": [
                {
                  "name": "account",
                  "type": 0
                }
              ],
              "output": 4,
              "docs": [
                " Get current account nonce of given `AccountId`."
              ]
            }
          ],
          "docs": [
            " The API to query account nonce."
          ]
        },
        {
          "name": "AssetsApi",
          "methods": [
            {
              "name": "account_balances",
              "inputs": [
                {
                  "name": "account",
                  "type": 0
                }
              ],
              "output": 631,
              "docs": [
                " Returns the list of `AssetId`s and corresponding balance that an `AccountId` has."
              ]
            }
          ],
          "docs": []
        },
        {
          "name": "ContractsApi",
          "methods": [
            {
              "name": "call",
              "inputs": [
                {
                  "name": "origin",
                  "type": 0
                },
                {
                  "name": "dest",
                  "type": 0
                },
                {
                  "name": "value",
                  "type": 6
                },
                {
                  "name": "gas_limit",
                  "type": 423
                },
                {
                  "name": "storage_deposit_limit",
                  "type": 331
                },
                {
                  "name": "input_data",
                  "type": 13
                }
              ],
              "output": 892,
              "docs": [
                " Perform a call from a specified account to a given contract.",
                "",
                " See [`crate::Pallet::bare_call`]."
              ]
            },
            {
              "name": "instantiate",
              "inputs": [
                {
                  "name": "origin",
                  "type": 0
                },
                {
                  "name": "value",
                  "type": 6
                },
                {
                  "name": "gas_limit",
                  "type": 423
                },
                {
                  "name": "storage_deposit_limit",
                  "type": 331
                },
                {
                  "name": "code",
                  "type": 899
                },
                {
                  "name": "data",
                  "type": 13
                },
                {
                  "name": "salt",
                  "type": 13
                }
              ],
              "output": 900,
              "docs": [
                " Instantiate a new contract.",
                "",
                " See `[crate::Pallet::bare_instantiate]`."
              ]
            },
            {
              "name": "upload_code",
              "inputs": [
                {
                  "name": "origin",
                  "type": 0
                },
                {
                  "name": "code",
                  "type": 13
                },
                {
                  "name": "storage_deposit_limit",
                  "type": 331
                },
                {
                  "name": "determinism",
                  "type": 262
                }
              ],
              "output": 903,
              "docs": [
                " Upload new code without instantiating a contract from it.",
                "",
                " See [`crate::Pallet::bare_upload_code`]."
              ]
            },
            {
              "name": "get_storage",
              "inputs": [
                {
                  "name": "address",
                  "type": 0
                },
                {
                  "name": "key",
                  "type": 13
                }
              ],
              "output": 905,
              "docs": [
                " Query a given storage key in a given contract.",
                "",
                " Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the",
                " specified account and `Ok(None)` if it doesn't. If the account specified by the address",
                " doesn't exist, or doesn't have a contract then `Err` is returned."
              ]
            }
          ],
          "docs": [
            " The API used to dry-run contract interactions."
          ]
        },
        {
          "name": "TransactionPaymentApi",
          "methods": [
            {
              "name": "query_info",
              "inputs": [
                {
                  "name": "uxt",
                  "type": 865
                },
                {
                  "name": "len",
                  "type": 4
                }
              ],
              "output": 907,
              "docs": []
            },
            {
              "name": "query_fee_details",
              "inputs": [
                {
                  "name": "uxt",
                  "type": 865
                },
                {
                  "name": "len",
                  "type": 4
                }
              ],
              "output": 908,
              "docs": []
            },
            {
              "name": "query_weight_to_fee",
              "inputs": [
                {
                  "name": "weight",
                  "type": 9
                }
              ],
              "output": 6,
              "docs": []
            },
            {
              "name": "query_length_to_fee",
              "inputs": [
                {
                  "name": "length",
                  "type": 4
                }
              ],
              "output": 6,
              "docs": []
            }
          ],
          "docs": []
        },
        {
          "name": "AssetConversionApi",
          "methods": [
            {
              "name": "quote_price_tokens_for_exact_tokens",
              "inputs": [
                {
                  "name": "asset1",
                  "type": 399
                },
                {
                  "name": "asset2",
                  "type": 399
                },
                {
                  "name": "amount",
                  "type": 6
                },
                {
                  "name": "include_fee",
                  "type": 43
                }
              ],
              "output": 331,
              "docs": [
                " Provides a quote for [`Pallet::swap_tokens_for_exact_tokens`].",
                "",
                " Note that the price may have changed by the time the transaction is executed.",
                " (Use `amount_in_max` to control slippage.)"
              ]
            },
            {
              "name": "quote_price_exact_tokens_for_tokens",
              "inputs": [
                {
                  "name": "asset1",
                  "type": 399
                },
                {
                  "name": "asset2",
                  "type": 399
                },
                {
                  "name": "amount",
                  "type": 6
                },
                {
                  "name": "include_fee",
                  "type": 43
                }
              ],
              "output": 331,
              "docs": [
                " Provides a quote for [`Pallet::swap_exact_tokens_for_tokens`].",
                "",
                " Note that the price may have changed by the time the transaction is executed.",
                " (Use `amount_out_min` to control slippage.)"
              ]
            },
            {
              "name": "get_reserves",
              "inputs": [
                {
                  "name": "asset1",
                  "type": 399
                },
                {
                  "name": "asset2",
                  "type": 399
                }
              ],
              "output": 911,
              "docs": [
                " Returns the size of the liquidity pool for the given asset pair."
              ]
            }
          ],
          "docs": [
            " This runtime api allows people to query the size of the liquidity pools",
            " and quote prices for swaps."
          ]
        },
        {
          "name": "TransactionPaymentCallApi",
          "methods": [
            {
              "name": "query_call_info",
              "inputs": [
                {
                  "name": "call",
                  "type": 141
                },
                {
                  "name": "len",
                  "type": 4
                }
              ],
              "output": 907,
              "docs": [
                " Query information of a dispatch class, weight, and fee of a given encoded `Call`."
              ]
            },
            {
              "name": "query_call_fee_details",
              "inputs": [
                {
                  "name": "call",
                  "type": 141
                },
                {
                  "name": "len",
                  "type": 4
                }
              ],
              "output": 908,
              "docs": [
                " Query fee details of a given encoded `Call`."
              ]
            },
            {
              "name": "query_weight_to_fee",
              "inputs": [
                {
                  "name": "weight",
                  "type": 9
                }
              ],
              "output": 6,
              "docs": [
                " Query the output of the current `WeightToFee` given some input."
              ]
            },
            {
              "name": "query_length_to_fee",
              "inputs": [
                {
                  "name": "length",
                  "type": 4
                }
              ],
              "output": 6,
              "docs": [
                " Query the output of the current `LengthToFee` given some input."
              ]
            }
          ],
          "docs": []
        },
        {
          "name": "NftsApi",
          "methods": [
            {
              "name": "owner",
              "inputs": [
                {
                  "name": "collection",
                  "type": 4
                },
                {
                  "name": "item",
                  "type": 4
                }
              ],
              "output": 42,
              "docs": []
            },
            {
              "name": "collection_owner",
              "inputs": [
                {
                  "name": "collection",
                  "type": 4
                }
              ],
              "output": 42,
              "docs": []
            },
            {
              "name": "attribute",
              "inputs": [
                {
                  "name": "collection",
                  "type": 4
                },
                {
                  "name": "item",
                  "type": 4
                },
                {
                  "name": "key",
                  "type": 13
                }
              ],
              "output": 448,
              "docs": []
            },
            {
              "name": "custom_attribute",
              "inputs": [
                {
                  "name": "account",
                  "type": 0
                },
                {
                  "name": "collection",
                  "type": 4
                },
                {
                  "name": "item",
                  "type": 4
                },
                {
                  "name": "key",
                  "type": 13
                }
              ],
              "output": 448,
              "docs": []
            },
            {
              "name": "system_attribute",
              "inputs": [
                {
                  "name": "collection",
                  "type": 4
                },
                {
                  "name": "item",
                  "type": 4
                },
                {
                  "name": "key",
                  "type": 13
                }
              ],
              "output": 448,
              "docs": []
            },
            {
              "name": "collection_attribute",
              "inputs": [
                {
                  "name": "collection",
                  "type": 4
                },
                {
                  "name": "key",
                  "type": 13
                }
              ],
              "output": 448,
              "docs": []
            }
          ],
          "docs": []
        },
        {
          "name": "MmrApi",
          "methods": [
            {
              "name": "mmr_root",
              "inputs": [],
              "output": 913,
              "docs": [
                " Return the on-chain MMR root hash."
              ]
            },
            {
              "name": "mmr_leaf_count",
              "inputs": [],
              "output": 915,
              "docs": [
                " Return the number of MMR blocks in the chain."
              ]
            },
            {
              "name": "generate_proof",
              "inputs": [
                {
                  "name": "block_numbers",
                  "type": 114
                },
                {
                  "name": "best_known_block_number",
                  "type": 38
                }
              ],
              "output": 916,
              "docs": [
                " Generate MMR proof for a series of block numbers. If `best_known_block_number = Some(n)`,",
                " use historical MMR state at given block height `n`. Else, use current MMR state."
              ]
            },
            {
              "name": "verify_proof",
              "inputs": [
                {
                  "name": "leaves",
                  "type": 918
                },
                {
                  "name": "proof",
                  "type": 920
                }
              ],
              "output": 921,
              "docs": [
                " Verify MMR proof against on-chain MMR for a batch of leaves.",
                "",
                " Note this function will use on-chain MMR root hash and check if the proof matches the hash.",
                " Note, the leaves should be sorted such that corresponding leaves and leaf indices have the",
                " same position in both the `leaves` vector and the `leaf_indices` vector contained in the [Proof]"
              ]
            },
            {
              "name": "verify_proof_stateless",
              "inputs": [
                {
                  "name": "root",
                  "type": 12
                },
                {
                  "name": "leaves",
                  "type": 918
                },
                {
                  "name": "proof",
                  "type": 920
                }
              ],
              "output": 921,
              "docs": [
                " Verify MMR proof against given root hash for a batch of leaves.",
                "",
                " Note this function does not require any on-chain storage - the",
                " proof is verified against given MMR root hash.",
                "",
                " Note, the leaves should be sorted such that corresponding leaves and leaf indices have the",
                " same position in both the `leaves` vector and the `leaf_indices` vector contained in the [Proof]"
              ]
            }
          ],
          "docs": [
            " API to interact with MMR pallet."
          ]
        },
        {
          "name": "SessionKeys",
          "methods": [
            {
              "name": "generate_session_keys",
              "inputs": [
                {
                  "name": "seed",
                  "type": 448
                }
              ],
              "output": 13,
              "docs": [
                " Generate a set of session keys with optionally using the given seed.",
                " The keys should be stored within the keystore exposed via runtime",
                " externalities.",
                "",
                " The seed needs to be a valid `utf8` string.",
                "",
                " Returns the concatenated SCALE encoded public keys."
              ]
            },
            {
              "name": "decode_session_keys",
              "inputs": [
                {
                  "name": "encoded",
                  "type": 13
                }
              ],
              "output": 922,
              "docs": [
                " Decode the given public session keys.",
                "",
                " Returns the list of public raw public keys + key type."
              ]
            }
          ],
          "docs": [
            " Session keys runtime api."
          ]
        }
      ],
      "outerEnums": {
        "callType": 141,
        "eventType": 20,
        "errorType": 925
      },
      "custom": {
        "map": {}
      }
    }
  }
}
